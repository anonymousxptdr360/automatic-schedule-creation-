<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Générateur d'horaires</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f8fafc; /* bg-slate-50 */
        }
        /* Style pour les champs */
        input[type="date"], input[type="time"], input[type="number"], select {
            border-width: 1px;
            border-color: #D1D5DB; /* gray-300 */
            border-radius: 0.375rem; /* rounded-md */
            padding: 0.5rem 0.75rem;
            width: 100%;
            box-shadow: 0 1px 2px 0 rgba(0, 0, 0, 0.05); /* shadow-sm */
            transition: all 0.2s ease-in-out;
        }
        input:focus, select:focus {
            outline: 2px solid transparent;
            outline-offset: 2px;
            border-color: #4f46e5; /* indigo-600 */
            box-shadow: 0 0 0 3px rgba(79, 70, 229, 0.2); /* ring */
        }
        
        /* Styles pour le Wizard */
        .wizard-step {
            /* transition: all 0.3s ease-out; */ /* On garde simple avec display */
        }

        .step-dot {
            width: 10px; height: 10px; background-color: #D1D5DB; /* gray-300 */
            border-radius: 50%; transition: all 0.2s;
            cursor: pointer;
        }
        .step-dot.active {
            background-color: #4f46e5; /* indigo-600 */
            transform: scale(1.25);
        }
    </style>
</head>
<body class="p-4 md:p-8">
    
    <!-- Boutons de langue -->
    <div class="max-w-4xl mx-auto flex justify-end mb-2 space-x-2">
        <button id="lang-fr" data-id="lang-fr" class="px-3 py-1 text-sm font-medium text-white bg-indigo-600 rounded-md shadow-sm opacity-100">FR</button>
        <button id="lang-en" data-id="lang-en" class="px-3 py-1 text-sm font-medium text-indigo-700 bg-white border border-gray-300 rounded-md shadow-sm opacity-70 hover:opacity-100">EN</button>
    </div>

    <!-- AJOUT DE L'ID PRINCIPAL CI-DESSOUS -->
    <div id="schedule-generator-app" class="max-w-4xl mx-auto bg-white p-6 md:p-8 rounded-xl shadow-2xl">
        <h1 class="text-3xl md:text-4xl font-bold text-transparent bg-clip-text bg-gradient-to-r from-indigo-600 to-purple-600 mb-6 border-b pb-4" data-i18n="title">Générateur d'horaires</h1>

        <!-- Conteneur du Wizard -->
        <div id="wizard-container" data-id="wizard-container" class="min-h-[400px]">
            
            <!-- Étape 1: Créneaux -->
            <div id="step-1" data-id="step-1" class="wizard-step">
                <!-- 1. Définir les créneaux (Palette) -->
                <div class="bg-white rounded-lg">
                    <h2 class="text-2xl font-semibold text-gray-800 mb-4" data-i18n="section1Title">1. Définir la "Palette" de créneaux</h2>
                    <div class="grid grid-cols-1 gap-4">
                        <div>
                            <label for="slot-day" class="block text-sm font-medium text-gray-600 mb-1" data-i18n="dayLabel">Jour de la semaine</label>
                            <select id="slot-day" data-id="slot-day">
                                <option value="1" data-i18n="day1">Lundi</option>
                                <option value="2" data-i18n="day2">Mardi</option>
                                <option value="3" data-i18n="day3">Mercredi</option>
                                <option value="4" data-i18n="day4">Jeudi</option>
                                <option value="5" data-i18n="day5">Vendredi</option>
                                <option value="6" data-i18n="day6">Samedi</option>
                                <option value="0" data-i18n="day0">Dimanche</option>
                            </select>
                        </div>
                        <div class="grid grid-cols-2 gap-3">
                            <div>
                                <label for="slot-start" class="block text-sm font-medium text-gray-600 mb-1" data-i18n="startLabel">Début (HH:mm)</label>
                                <input type="time" id="slot-start" data-id="slot-start" value="18:30">
                            </div>
                            <div>
                                <label for="slot-end" class="block text-sm font-medium text-gray-600 mb-1" data-i18n="endLabel">Fin (HH:mm)</label>
                                <input type="time" id="slot-end" data-id="slot-end" value="20:00">
                            </div>
                        </div>
                        <button id="add-slot-btn" data-id="add-slot-btn" class="w-full bg-indigo-600 hover:bg-indigo-700 text-white font-medium py-2 px-4 rounded-lg shadow-md transition-colors">
                            <span data-i18n="addSlotBtn">+ Ajouter ce créneau</span>
                        </button>
                    </div>
                    <div class="mt-4">
                        <h3 class="text-md font-medium text-gray-600" data-i18n="definedSlots">Créneaux possibles :</h3>
                        <ul id="slots-list" data-id="slots-list" class="list-disc list-inside text-sm text-gray-700 mt-2 space-y-1"></ul>
                    </div>
                </div>
            </div>

            <!-- Étape 2: Périodes -->
            <div id="step-2" data-id="step-2" class="wizard-step" style="display: none;">
                <!-- 2. Organiser les Périodes -->
                <div class="bg-white rounded-lg">
                    <h2 class="text-2xl font-semibold text-gray-800 mb-4" data-i18n="section2Title">2. Organiser les Périodes</h2>
                    <div id="periods-list-container" data-id="periods-list-container" class="flex flex-col gap-4">
                        <!-- Les cartes de période seront injectées ici -->
                    </div>
                    <button id="add-period-btn" data-id="add-period-btn" class="w-full bg-blue-500 hover:bg-blue-600 text-white font-medium py-2 px-4 rounded-lg shadow-md transition-colors mt-4">
                        <span data-i18n="addPeriodBtn">+ Ajouter une période</span>
                    </button>
                </div>
            </div>

            <!-- Étape 3: Pauses -->
            <div id="step-3" data-id="step-3" class="wizard-step" style="display: none;">
                <!-- 3. Définir les pauses -->
                <div class="bg-white rounded-lg">
                    <h2 class="text-2xl font-semibold text-gray-800 mb-4" data-i18n="section3Title">3. Définir les pauses (Vacances)</h2>
                    <div class="grid grid-cols-2 gap-3">
                        <div>
                            <label for="break-start" class="block text-sm font-medium text-gray-600 mb-1" data-i18n="breakStartLabel">Début de la pause</label>
                            <input type="date" id="break-start" data-id="break-start">
                        </div>
                        <div>
                            <label for="break-end" class="block text-sm font-medium text-gray-600 mb-1" data-i18n="breakEndLabel">Fin de la pause</label>
                            <input type="date" id="break-end" data-id="break-end">
                        </div>
                    </div>
                    <button id="add-break-btn" data-id="add-break-btn" class="w-full bg-amber-500 hover:bg-amber-600 text-white font-medium py-2 px-4 rounded-lg shadow-md transition-colors mt-4">
                        <span data-i18n="addBreakBtn">+ Ajouter cette pause</span>
                    </button>
                    <div class="mt-4">
                        <h3 class="text-md font-medium text-gray-600" data-i18n="definedBreaks">Pauses définies :</h3>
                        <ul id="breaks-list" data-id="breaks-list" class="list-disc list-inside text-sm text-gray-700 mt-2 space-y-1"></ul>
                    </div>
                </div>
            </div>

            <!-- Étape 4: Génération & Formatage -->
            <div id="step-4" data-id="step-4" class="wizard-step" style="display: none;">
                <!-- 4. Lancer la génération -->
                <div class="bg-white rounded-lg">
                    <h2 class="text-2xl font-semibold text-gray-800 mb-4" data-i18n="section4Title">4. Lancer la génération</h2>
                    <div class="grid grid-cols-1 gap-3">
                        <div>
                            <label for="start-date" class="block text-sm font-medium text-gray-600 mb-1" data-i18n="startDateLabel">Date de début globale</label>
                            <input type="date" id="start-date" data-id="start-date">
                        </div>
                        
                        <!-- Date de fin globale optionnelle -->
                        <div class="mt-2">
                            <label class="flex items-center space-x-3 cursor-pointer">
                                <input type="checkbox" id="use-global-end-date" data-id="use-global-end-date" class="w-5 h-5 text-indigo-600 rounded border-gray-300 focus:ring-indigo-500">
                                <span class="text-sm font-medium text-gray-700" data-i18n="useGlobalEndDate">Ajouter une date de fin globale (optionnel)</span>
                            </label>
                        </div>
                        <div id="global-end-date-container" data-id="global-end-date-container" class="mt-1" style="display: none;">
                            <label for="global-end-date" class="block text-sm font-medium text-gray-600 mb-1" data-i18n="globalEndDateLabel">Date de fin globale</label>
                            <input type="date" id="global-end-date" data-id="global-end-date">
                        </div>
                    </div>
                </div>
                
                <!-- 5. Options de formatage -->
                <div class="bg-white rounded-lg mt-8">
                    <h2 class="text-2xl font-semibold text-gray-800 mb-4" data-i18n="section5Title">5. Options de formatage</h2>
                    <div class="flex flex-col space-y-3">
                        <label class="flex items-center space-x-3 cursor-pointer">
                            <input type="checkbox" id="show-day-of-week" data-id="show-day-of-week" class="w-5 h-5 text-indigo-600 rounded border-gray-300 focus:ring-indigo-500" checked>
                            <span class="text-sm font-medium text-gray-700" data-i18n="showDayOfWeek">Afficher le jour de la semaine (ex: Lundi)</span>
                        </label>
                        <label class="flex items-center space-x-3 cursor-pointer">
                            <input type="checkbox" id="show-year" data-id="show-year" class="w-5 h-5 text-indigo-600 rounded border-gray-300 focus:ring-indigo-500">
                            <span class="text-sm font-medium text-gray-700" data-i18n="showYear">Afficher l'année (ex: 2025)</span>
                        </label>
                    </div>
                </div>
            </div>

            <!-- Étape 5: Résultats -->
            <div id="step-5" data-id="step-5" class="wizard-step" style="display: none;">
                <!-- 6. Résultats -->
                <div class="bg-white rounded-lg h-full flex flex-col">
                    <h2 class="text-2xl font-semibold text-gray-800 mb-4" data-i18n="section6Title">6. Résultats</h2>
                    
                    <div id="total-hours-display" data-id="total-hours-display" class="bg-indigo-100 text-indigo-800 text-2xl font-bold p-4 rounded-lg text-center mb-6" style="display: none;">
                        <span data-i18n="total">Total</span> : <span id="total-hours" data-id="total-hours">0</span> <span data-i18n="hours">heures</span>
                    </div>

                    <div class="relative flex-grow h-[400px] overflow-y-auto bg-gray-50 border border-gray-300 rounded-lg p-4">
                        <pre id="results-list" data-id="results-list" class="text-gray-700 text-sm whitespace-pre-wrap font-sans"></pre>
                    </div>
                    
                    <!-- Section Copie -->
                    <div class="mt-6">
                        <h3 class="text-lg font-semibold text-gray-700" data-i18n="copyTitle">Copier les résultats</h3>
                        <div class="flex items-center space-x-4 my-3 bg-gray-100 p-2 rounded-lg">
                            <input type="radio" id="copy-format-vertical" data-id="copy-format-vertical" name="copy-format" value="vertical" class="w-4 h-4 text-indigo-600" checked>
                            <label for="copy-format-vertical" class="text-sm font-medium text-gray-700" data-i18n="copyVertical">Vertical</label>
                            
                            <input type="radio" id="copy-format-horizontal" data-id="copy-format-horizontal" name="copy-format" value="horizontal" class="w-4 h-4 text-indigo-600">
                            <label for="copy-format-horizontal" class="text-sm font-medium text-gray-700" data-i18n="copyHorizontal">Horizontal</label>
                        </div>

                        <div class="h-24 overflow-y-auto bg-gray-50 border border-gray-300 rounded-lg p-3 text-xs text-gray-600">
                            <pre id="copy-preview" data-id="copy-preview"></pre>
                        </div>
                        
                        <button id="copy-btn" data-id="copy-btn" class="w-full bg-gray-700 hover:bg-gray-800 text-white font-medium py-2 px-4 rounded-lg shadow-md transition-colors mt-4 relative">
                            <span id="copy-btn-text" data-id="copy-btn-text" data-i18n="copyBtn">Copier</span>
                            <div id="copy-feedback-success" data-id="copy-feedback-success" class="absolute inset-0 bg-emerald-500 rounded-lg flex items-center justify-center text-white" style="opacity: 0; transition: opacity 0.3s ease-out; pointer-events: none;">
                                <!-- Checkmark SVG -->
                                <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M5 13l4 4L19 7"></path></svg>
                            </div>
                        </button>
                    </div>
                </div>
            </div>
        </div>

        <!-- Indicateur d'étape -->
        <div id="step-indicator" data-id="step-indicator" class="flex justify-center items-center space-x-3 mt-6">
            <span class="step-dot active" data-step="1"></span>
            <span class="step-dot" data-step="2"></span>
            <span class="step-dot" data-step="3"></span>
            <span class="step-dot" data-step="4"></span>
            <span class="step-dot" data-step="5"></span>
        </div>

        <!-- Navigation du Wizard -->
        <div id="wizard-navigation" data-id="wizard-navigation" class="flex justify-between mt-8 pt-6 border-t">
            <button id="prev-btn" data-id="prev-btn" class="bg-gray-200 hover:bg-gray-300 text-gray-800 font-medium py-2 px-6 rounded-lg shadow-md transition-colors" data-i18n="back">
                Retour
            </button>
            <button id="next-btn" data-id="next-btn" class="bg-indigo-600 hover:bg-indigo-700 text-white font-medium py-2 px-6 rounded-lg shadow-md transition-colors" data-i18n="next">
                Suivant
            </button>
        </div>

    </div>

    <script>
        // Encapsuler tout le script pour éviter les conflits
        function initScheduleGenerator() {
            // Sélectionner le conteneur principal
            const app = document.getElementById('schedule-generator-app');
            if (!app) {
                console.error("Erreur: Le conteneur principal #schedule-generator-app est introuvable. L'application ne peut pas démarrer.");
                return;
            }

            // --- STATE ---
            let slots = []; // { id, day, start, end, duration }
            let periods = []; // { id, targetType, targetValue, activeSlotIds: [] }
            let breaks = [];
            let generatedSessions = []; // Stocke { date, slot }
            let currentLang = 'fr';
            
            // NOUVEL ÉTAT POUR LE WIZARD
            let currentStep = 1;
            const totalSteps = 5;

            // --- i18n (Traduction) ---
            const translations = {
                fr: {
                    title: "Générateur d'horaires",
                    section1Title: "1. Définir la \"Palette\" de créneaux",
                    dayLabel: "Jour de la semaine",
                    day1: "Lundi", day2: "Mardi", day3: "Mercredi", day4: "Jeudi", day5: "Vendredi", day6: "Samedi", day0: "Dimanche",
                    startLabel: "Début (HH:mm)",
                    endLabel: "Fin (HH:mm)",
                    addSlotBtn: "+ Ajouter ce créneau",
                    definedSlots: "Créneaux possibles :",
                    section2Title: "2. Organiser les Périodes",
                    addPeriodBtn: "+ Ajouter une période",
                    periodTitle: (num) => `Période ${num}`,
                    periodTarget: "Objectif de la période",
                    periodTargetWeeks: "Durée (semaines)",
                    periodTargetDate: "Date de fin",
                    periodActiveSlots: "Créneaux actifs pour cette période",
                    noSlotsForPeriod: "Définissez des créneaux dans la Section 1 pour les activer ici.",
                    section3Title: "3. Définir les pauses (Vacances)",
                    breakStartLabel: "Début de la pause",
                    breakEndLabel: "Fin de la pause",
                    addBreakBtn: "+ Ajouter cette pause",
                    definedBreaks: "Pauses définies :",
                    section4Title: "4. Lancer la génération",
                    startDateLabel: "Date de début globale",
                    useGlobalEndDate: "Ajouter une date de fin globale (optionnel)",
                    globalEndDateLabel: "Date de fin globale",
                    generateBtn: "Générer l'horaire",
                    section5Title: "5. Options de formatage",
                    showDayOfWeek: "Afficher le jour de la semaine (ex: Lundi)",
                    showYear: "Afficher l'année (ex: 2025)",
                    section6Title: "6. Résultats",
                    total: "Total",
                    hours: "heures",
                    copyTitle: "Copier les résultats",
                    copyVertical: "Vertical",
                    copyHorizontal: "Horizontal (ex: ... - ...)",
                    copyBtn: "Copier",
                    errorMsg: "Erreur : Veuillez définir au moins un créneau (Section 1) et une date de début (Section 4). Si vous n'utilisez pas de 'Périodes', la 'Date de fin globale' est obligatoire.",
                    noSessionsMsg: "Aucune session n'a pu être générée avec ces paramètres.",
                    slotName: (day, start, end, duration) => `${day} de ${start} à ${end} (${duration.toFixed(2)}h)`,
                    breakName: (start, end) => `du ${start} au ${end}`,
                    copied: "Copié !",
                    // Nouveaux textes pour le wizard
                    next: "Suivant",
                    back: "Retour"
                },
                en: {
                    title: "Schedule Generator",
                    section1Title: "1. Define \"Palette\" of slots",
                    dayLabel: "Day of the week",
                    day1: "Monday", day2: "Tuesday", day3: "Wednesday", day4: "Thursday", day5: "Friday", day6: "Saturday", day0: "Sunday",
                    startLabel: "Start (HH:mm)",
                    endLabel: "End (HH:mm)",
                    addSlotBtn: "+ Add this slot",
                    definedSlots: "Possible slots:",
                    section2Title: "2. Organize Periods",
                    addPeriodBtn: "+ Add a period",
                    periodTitle: (num) => `Period ${num}`,
                    periodTarget: "Period target",
                    periodTargetWeeks: "Duration (weeks)",
                    periodTargetDate: "End date",
                    periodActiveSlots: "Active slots for this period",
                    noSlotsForPeriod: "Define slots in Section 1 to activate them here.",
                    section3Title: "3. Define breaks (Holidays)",
                    breakStartLabel: "Break start",
                    breakEndLabel: "Break end",
                    addBreakBtn: "+ Add this break",
                    definedBreaks: "Defined breaks:",
                    section4Title: "4. Start Generation",
                    startDateLabel: "Global start date",
                    useGlobalEndDate: "Add global end date (optional)",
                    globalEndDateLabel: "Global End Date",
                    generateBtn: "Generate Schedule",
                    section5Title: "5. Formatting Options",
                    showDayOfWeek: "Show day of week (e.g., Monday)",
                    showYear: "Show year (e.g., 2025)",
                    section6Title: "6. Results",
                    total: "Total",
                    hours: "hours",
                    copyTitle: "Copy results",
                    copyVertical: "Vertical",
                    copyHorizontal: "Horizontal (e.g., ... - ...)",
                    copyBtn: "Copy",
                    errorMsg: "Error: Please define at least one slot (Section 1) and a start date (Section 4). If not using 'Periods', a 'Global End Date' is required.",
                    noSessionsMsg: "No sessions could be generated with these parameters.",
                    slotName: (day, start, end, duration) => `${day} from ${start} to ${end} (${duration.toFixed(2)}h)`,
                    breakName: (start, end) => `from ${start} to ${end}`,
                    copied: "Copied!",
                    // Nouveaux textes pour le wizard
                    next: "Next",
                    back: "Back"
                }
            };

            // Utiliser app.querySelectorAll pour être plus robuste
            const i18nElems = app.querySelectorAll('[data-i18n]');
            const dayNames = {
                fr: ["Dimanche", "Lundi", "Mardi", "Mercredi", "Jeudi", "Vendredi", "Samedi"],
                en: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"]
            };

            function setLanguage(lang) {
                if (lang === currentLang) return;
                currentLang = lang;
                
                // Mettre à jour les boutons de langue (en dehors de la div 'app' mais on garde les data-id pour la cohérence)
                const langFrBtn = document.querySelector('[data-id="lang-fr"]');
                const langEnBtn = document.querySelector('[data-id="lang-en"]');
                
                langFrBtn.classList.toggle('opacity-70', lang !== 'fr');
                langFrBtn.classList.toggle('bg-white', lang !== 'fr');
                langFrBtn.classList.toggle('text-indigo-700', lang !== 'fr');
                langFrBtn.classList.toggle('opacity-100', lang === 'fr');
                langFrBtn.classList.toggle('bg-indigo-600', lang === 'fr');
                langFrBtn.classList.toggle('text-white', lang === 'fr');
                
                langEnBtn.classList.toggle('opacity-70', lang !== 'en');
                langEnBtn.classList.toggle('bg-white', lang !== 'en');
                langEnBtn.classList.toggle('text-indigo-700', lang !== 'en');
                langEnBtn.classList.toggle('opacity-100', lang === 'en');
                langEnBtn.classList.toggle('bg-indigo-600', lang === 'en');
                langEnBtn.classList.toggle('text-white', lang === 'en');

                // Mettre à jour les textes
                const t = translations[lang];
                i18nElems.forEach(el => {
                    const key = el.getAttribute('data-i18n');
                    if (t[key] && typeof t[key] === 'string') { // Vérifier si c'est une string
                        el.textContent = t[key];
                    }
                });
                
                // Mettre à jour les options du select
                const select = app.querySelector('[data-id="slot-day"]');
                if (select) {
                    Array.from(select.options).forEach(opt => {
                        const key = `day${opt.value}`;
                        if(t[key]) opt.textContent = t[key];
                    });
                }

                // Rafraîchir les listes et les résultats
                updateSlotsList();
                updateBreaksList();
                // Rafraîchir les titres des périodes
                app.querySelectorAll('.period-card').forEach((pCard, index) => {
                    pCard.querySelector('h3').textContent = t.periodTitle(index + 1);
                });
                // Rafraîchir les checkboxes des périodes
                updateAllPeriodCheckboxLists();
                renderResults();
                // Mettre à jour l'UI du Wizard (texte des boutons)
                updateWizardUI();
            }

            // Mettre les écouteurs en dehors de la div 'app'
            document.querySelector('[data-id="lang-fr"]').addEventListener('click', () => setLanguage('fr'));
            document.querySelector('[data-id="lang-en"]').addEventListener('click', () => setLanguage('en'));

            // --- ÉLÉMENTS DU DOM (Utiliser app.querySelector) ---
            const addSlotBtn = app.querySelector('[data-id="add-slot-btn"]');
            const slotsList = app.querySelector('[data-id="slots-list"]');
            
            const addPeriodBtn = app.querySelector('[data-id="add-period-btn"]');
            const periodsListContainer = app.querySelector('[data-id="periods-list-container"]');

            const addBreakBtn = app.querySelector('[data-id="add-break-btn"]');
            const breaksList = app.querySelector('[data-id="breaks-list"]');
 
            const useGlobalEndDateCheckbox = app.querySelector('[data-id="use-global-end-date"]');
            const globalEndDateContainer = app.querySelector('[data-id="global-end-date-container"]');
            const globalEndDateInput = app.querySelector('[data-id="global-end-date"]');

            const resultsList = app.querySelector('[data-id="results-list"]');
            const totalHoursDisplay = app.querySelector('[data-id="total-hours-display"]');
            const totalHoursEl = app.querySelector('[data-id="total-hours"]');
            
            const showDayOfWeek = app.querySelector('[data-id="show-day-of-week"]');
            const showYear = app.querySelector('[data-id="show-year"]');

            const copyBtn = app.querySelector('[data-id="copy-btn"]');
            const copyBtnText = app.querySelector('[data-id="copy-btn-text"]');
            const copyFeedbackSuccess = app.querySelector('[data-id="copy-feedback-success"]');
            const copyFormatVertical = app.querySelector('[data-id="copy-format-vertical"]');
            const copyFormatHorizontal = app.querySelector('[data-id="copy-format-horizontal"]');
            const copyPreview = app.querySelector('[data-id="copy-preview"]');

            const prevBtn = app.querySelector('[data-id="prev-btn"]');
            const nextBtn = app.querySelector('[data-id="next-btn"]');
            const wizardSteps = app.querySelectorAll('.wizard-step');
            const stepDots = app.querySelectorAll('.step-dot');

            // --- LOGIQUE ---

            // (Section 1: Créneaux)
            if (addSlotBtn) {
                addSlotBtn.addEventListener('click', () => {
                    const day = app.querySelector('[data-id="slot-day"]').value;
                    const start = app.querySelector('[data-id="slot-start"]').value;
                    const end = app.querySelector('[data-id="slot-end"]').value;

                    if (!start || !end) {
                        console.error("Veuillez remplir les heures de début et de fin");
                        return;
                    }

                    const [startH, startM] = start.split(':').map(Number);
                    const [endH, endM] = end.split(':').map(Number);
                    
                    let durationInMinutes = (endH * 60 + endM) - (startH * 60 + startM);
                    if (durationInMinutes < 0) {
                        durationInMinutes += 24 * 60;
                    }
                    
                    const durationInHours = durationInMinutes / 60;

                    const slot = {
                        id: `slot_${crypto.randomUUID()}`,
                        day: parseInt(day),
                        start: start,
                        end: end,
                        duration: durationInHours
                    };
                    
                    slots.push(slot);
                    updateSlotsList();
                    updateAllPeriodCheckboxLists(); // Mettre à jour les périodes
                });
            }

            function updateSlotsList() {
                if (!slotsList) return;
                slotsList.innerHTML = '';
                const t = translations[currentLang];
                slots.forEach((slot, index) => {
                    const li = document.createElement('li');
                    const dayName = dayNames[currentLang][slot.day];
                    li.textContent = t.slotName(dayName, slot.start, slot.end, slot.duration);
                    li.className = 'flex justify-between items-center';
                    
                    const removeBtn = createRemoveBtn(() => {
                        removeSlot(slot.id);
                    });
                    li.appendChild(removeBtn);
                    
                    slotsList.appendChild(li);
                });
            }

            function removeSlot(slotId) {
                slots = slots.filter(s => s.id !== slotId);
                periods.forEach(p => {
                    p.activeSlotIds = p.activeSlotIds.filter(id => id !== slotId);
                });
                updateSlotsList();
                updateAllPeriodCheckboxLists();
            }

            function createRemoveBtn(onClick) {
                const removeBtn = document.createElement('button');
                removeBtn.textContent = 'x';
                removeBtn.className = 'text-red-500 hover:text-red-700 font-bold ml-2 text-xs';
                removeBtn.onclick = onClick;
                return removeBtn;
            }

            // (Section 2: Périodes)
            if (addPeriodBtn) {
                addPeriodBtn.addEventListener('click', () => {
                    const periodId = `period_${crypto.randomUUID()}`;
                    const newPeriod = {
                        id: periodId,
                        targetType: 'weeks',
                        targetValue: 5,
                        activeSlotIds: []
                    };
                    periods.push(newPeriod);
                    
                    if (periodsListContainer) {
                        periodsListContainer.appendChild(createPeriodCard(newPeriod));
                    }
                });
            }

            function createPeriodCard(period) {
                const t = translations[currentLang];
                const card = document.createElement('div');
                card.id = `period-card-${period.id}`;
                card.dataset.periodId = period.id;
                card.className = 'period-card bg-gray-50 p-4 rounded-lg border border-gray-200 shadow-inner';

                const cardHeader = document.createElement('div');
                cardHeader.className = 'flex justify-between items-center mb-3';
                
                const title = document.createElement('h3');
                title.className = 'text-lg font-semibold text-indigo-700';
                title.textContent = t.periodTitle(periods.indexOf(period) + 1);
                
                const removeBtn = createRemoveBtn(() => {
                    periods = periods.filter(p => p.id !== period.id);
                    card.remove();
                    const t = translations[currentLang];
                    app.querySelectorAll('.period-card').forEach((pCard, index) => {
                        pCard.querySelector('h3').textContent = t.periodTitle(index + 1);
                    });
                });
                removeBtn.className = 'text-red-500 hover:text-red-700 font-bold text-lg';

                cardHeader.appendChild(title);
                cardHeader.appendChild(removeBtn);
                card.appendChild(cardHeader);

                // ... (Le reste de la création de carte est auto-contenu et n'a pas besoin de app.querySelector)
                // --- Objectif de la période ---
                const targetLabel = document.createElement('label');
                targetLabel.className = 'block text-sm font-medium text-gray-600 mb-2';
                targetLabel.textContent = t.periodTarget;
                card.appendChild(targetLabel);

                const targetContainer = document.createElement('div');
                targetContainer.className = 'flex gap-2 mb-4';

                // Radio: Durée
                const radioWeeksDiv = document.createElement('div');
                radioWeeksDiv.className = 'flex items-center';
                const radioWeeks = document.createElement('input');
                radioWeeks.type = 'radio';
                radioWeeks.id = `period-target-weeks-${period.id}`;
                radioWeeks.name = `period-target-${period.id}`;
                radioWeeks.value = 'weeks';
                radioWeeks.checked = period.targetType === 'weeks';
                radioWeeks.className = 'w-4 h-4 text-indigo-600';
                const labelWeeks = document.createElement('label');
                labelWeeks.htmlFor = radioWeeks.id;
                labelWeeks.textContent = t.periodTargetWeeks;
                labelWeeks.className = 'ml-2 text-sm text-gray-700';
                radioWeeksDiv.appendChild(radioWeeks);
                radioWeeksDiv.appendChild(labelWeeks);

                // Radio: Date
                const radioDateDiv = document.createElement('div');
                radioDateDiv.className = 'flex items-center';
                const radioDate = document.createElement('input');
                radioDate.type = 'radio';
                radioDate.id = `period-target-date-${period.id}`;
                radioDate.name = `period-target-${period.id}`;
                radioDate.value = 'date';
                radioDate.checked = period.targetType === 'date';
                radioDate.className = 'w-4 h-4 text-indigo-600';
                const labelDate = document.createElement('label');
                labelDate.htmlFor = radioDate.id;
                labelDate.textContent = t.periodTargetDate;
                labelDate.className = 'ml-2 text-sm text-gray-700';
                radioDateDiv.appendChild(radioDate);
                radioDateDiv.appendChild(labelDate);

                targetContainer.appendChild(radioWeeksDiv);
                targetContainer.appendChild(radioDateDiv);
                card.appendChild(targetContainer);
                
                // --- Valeur de l'objectif ---
                const valueContainer = document.createElement('div');
                const inputWeeks = document.createElement('input');
                inputWeeks.type = 'number';
                inputWeeks.min = '1';
                inputWeeks.value = (period.targetType === 'weeks') ? period.targetValue : 5;
                inputWeeks.style.display = (period.targetType === 'weeks') ? 'block' : 'none';
                inputWeeks.onchange = (e) => period.targetValue = parseInt(e.target.value);

                const inputDate = document.createElement('input');
                inputDate.type = 'date';
                inputDate.value = (period.targetType === 'date') ? (period.targetValue || new Date().toISOString().split('T')[0]) : new Date().toISOString().split('T')[0];
                inputDate.style.display = (period.targetType === 'date') ? 'block' : 'none';
                inputDate.onchange = (e) => period.targetValue = e.target.value;
                
                valueContainer.appendChild(inputWeeks);
                valueContainer.appendChild(inputDate);
                card.appendChild(valueContainer);

                // Logique des radios
                radioWeeks.onchange = () => {
                    period.targetType = 'weeks';
                    period.targetValue = parseInt(inputWeeks.value);
                    inputWeeks.style.display = 'block';
                    inputDate.style.display = 'none';
                };
                radioDate.onchange = () => {
                    period.targetType = 'date';
                    period.targetValue = inputDate.value || new Date().toISOString().split('T')[0];
                    inputWeeks.style.display = 'none';
                    inputDate.style.display = 'block';
                };


                // --- Checkboxes de Créneaux Actifs ---
                const slotsLabel = document.createElement('label');
                slotsLabel.className = 'block text-sm font-medium text-gray-600 mt-4 mb-2';
                slotsLabel.textContent = t.periodActiveSlots;
                card.appendChild(slotsLabel);

                const checkboxContainer = document.createElement('div');
                checkboxContainer.className = 'checkbox-container space-y-2';
                card.appendChild(checkboxContainer);

                updatePeriodCheckboxList(period, card); // Remplir les checkboxes

                return card;
            }

            function updateAllPeriodCheckboxLists() {
                app.querySelectorAll('.period-card').forEach(card => {
                    const periodId = card.dataset.periodId;
                    const period = periods.find(p => p.id === periodId);
                    if (period) {
                        updatePeriodCheckboxList(period, card);
                    }
                });
            }

            function updatePeriodCheckboxList(period, card) {
                const t = translations[currentLang];
                const checkboxContainer = card.querySelector('.checkbox-container');
                if (!checkboxContainer) return;
                checkboxContainer.innerHTML = ''; // Vider

                if (slots.length === 0) {
                    checkboxContainer.textContent = t.noSlotsForPeriod;
                    return;
                }

                slots.forEach(slot => {
                    const slotName = t.slotName(dayNames[currentLang][slot.day], slot.start, slot.end, slot.duration);
                    
                    const label = document.createElement('label');
                    label.className = 'flex items-center space-x-3 cursor-pointer';
                    
                    const input = document.createElement('input');
                    input.type = 'checkbox';
                    input.value = slot.id;
                    input.className = 'w-4 h-4 text-indigo-600 rounded border-gray-300 focus:ring-indigo-500';
                    input.checked = period.activeSlotIds.includes(slot.id);

                    input.onchange = (e) => {
                        if (e.target.checked) {
                            if (!period.activeSlotIds.includes(slot.id)) {
                                period.activeSlotIds.push(slot.id);
                            }
                        } else {
                            period.activeSlotIds = period.activeSlotIds.filter(id => id !== slot.id);
                        }
                    };

                    const span = document.createElement('span');
                    span.className = 'text-sm text-gray-700';
                    span.textContent = slotName;

                    label.appendChild(input);
                    label.appendChild(span);
                    checkboxContainer.appendChild(label);
                });
            }


            // (Section 3: Pauses)
            if (addBreakBtn) {
                addBreakBtn.addEventListener('click', () => {
                    const start = app.querySelector('[data-id="break-start"]').value;
                    const end = app.querySelector('[data-id="break-end"]').value;

                    if (!start || !end) {
                        console.error("Veuillez remplir les dates de début et de fin de pause");
                        return;
                    }

                    const breakStart = parseDateAsUTC(start);
                    const breakEnd = parseDateAsUTC(end);
                    if (!breakStart || !breakEnd) return; 
                    breakEnd.setUTCHours(23, 59, 59, 999);

                    const breakPeriod = {
                        start: breakStart,
                        end: breakEnd
                    };
                    
                    breaks.push(breakPeriod);
                    updateBreaksList();
                });
            }

            function updateBreaksList() {
                if (!breaksList) return;
                breaksList.innerHTML = '';
                const t = translations[currentLang];
                breaks.forEach((b, index) => {
                    const li = document.createElement('li');
                    li.textContent = t.breakName(formatDate(b.start, currentLang, { showDay: false, showYear: false }), formatDate(b.end, currentLang, { showDay: false, showYear: false }));
                    li.className = 'flex justify-between items-center';
                    
                    const removeBtn = createRemoveBtn(() => {
                        breaks.splice(index, 1);
                        updateBreaksList();
                    });
                    li.appendChild(removeBtn);
                    
                    breaksList.appendChild(li);
                });
            }
            
            // (Section 4: Génération - Listener pour checkbox)
            if (useGlobalEndDateCheckbox) {
                useGlobalEndDateCheckbox.addEventListener('change', (e) => {
                    if (globalEndDateContainer) {
                        globalEndDateContainer.style.display = e.target.checked ? 'block' : 'none';
                    }
                });
            }

            // (Section 4: Logique de génération, maintenant dans une fonction)
            function runGenerationLogic() {
                const startDateInput = app.querySelector('[data-id="start-date"]').value;
                const useGlobalEndDate = useGlobalEndDateCheckbox.checked;
                const globalEndDateInputVal = globalEndDateInput.value;
                const t = translations[currentLang];

                // --- VÉRIFICATION ---
                if (!startDateInput || slots.length === 0) {
                    resultsList.textContent = t.errorMsg;
                    totalHoursDisplay.style.display = 'none';
                    return false; // Échec
                }
                
                if (periods.length === 0 && !useGlobalEndDate) {
                    resultsList.textContent = t.errorMsg;
                    totalHoursDisplay.style.display = 'none';
                    return false; // Échec
                }
                // --- FIN VÉRIFICATION ---

                let globalEndDate = null;
                if (useGlobalEndDate && globalEndDateInputVal) {
                    globalEndDate = parseDateAsUTC(globalEndDateInputVal);
                    if (globalEndDate) globalEndDate.setUTCHours(23, 59, 59, 999);
                }

                generatedSessions = []; 
                let currentDate = parseDateAsUTC(startDateInput); 
                if (!currentDate) {
                    resultsList.textContent = t.errorMsg;
                    totalHoursDisplay.style.display = 'none';
                    return false; // Échec
                }
                let totalHours = 0;
                let safetyCounter = 0; 
                let stopGeneration = false;

                // --- LOGIQUE: SI/SINON PÉRIODES ---
                if (periods.length > 0) {
                    // CAS 1: L'utilisateur a défini des périodes
                    for (const period of periods) {
                        if (stopGeneration) break;

                        let periodEndDate;
                        if (period.targetType === 'weeks') {
                            periodEndDate = new Date(currentDate.getTime());
                            periodEndDate.setUTCDate(periodEndDate.getUTCDate() + (period.targetValue * 7));
                        } else { 
                            periodEndDate = parseDateAsUTC(period.targetValue);
                        }
                        if (!periodEndDate) continue; 
                        periodEndDate.setUTCHours(23, 59, 59, 999); 

                        const activeSlots = period.activeSlotIds.map(id => slots.find(s => s.id === id)).filter(Boolean);
                        if (activeSlots.length === 0) {
                            currentDate = new Date(periodEndDate.getTime());
                            currentDate.setUTCDate(currentDate.getUTCDate() + 1); 
                            continue;
                        }

                        while (currentDate <= periodEndDate && (!globalEndDate || currentDate <= globalEndDate) && safetyCounter < (365 * 5)) {
                            const currentDayOfWeek = currentDate.getUTCDay();

                            let isBreak = false;
                            for (const b of breaks) {
                                if (currentDate >= b.start && currentDate <= b.end) {
                                    isBreak = true;
                                    break;
                                }
                            }

                            if (!isBreak) {
                                for (const slot of activeSlots) {
                                    if (slot.day === currentDayOfWeek) {
                                        generatedSessions.push({ date: new Date(currentDate.getTime()), slot: slot });
                                        totalHours += slot.duration;
                                        break; 
                                    }
                                }
                            }

                            currentDate.setUTCDate(currentDate.getUTCDate() + 1);
                            safetyCounter++;
                        }
                        
                        if (globalEndDate && currentDate > globalEndDate) {
                            stopGeneration = true;
                        }
                    }
                } else {
                    // CAS 2: AUCUNE période définie.
                    if (!globalEndDate) {
                        resultsList.textContent = t.errorMsg;
                        return false; // Échec
                    }
                    
                    const activeSlots = slots; // Utiliser TOUS les créneaux

                    while (currentDate <= globalEndDate && safetyCounter < (365 * 5)) {
                        const currentDayOfWeek = currentDate.getUTCDay();

                        let isBreak = false;
                        for (const b of breaks) {
                            if (currentDate >= b.start && currentDate <= b.end) {
                                isBreak = true;
                                break;
                            }
                        }

                        if (!isBreak) {
                            for (const slot of activeSlots) {
                                if (slot.day === currentDayOfWeek) {
                                    generatedSessions.push({ date: new Date(currentDate.getTime()), slot: slot });
                                    totalHours += slot.duration;
                                    break;
                                }
                            }
                        }

                        currentDate.setUTCDate(currentDate.getUTCDate() + 1);
                        safetyCounter++;
                    }
                }
                // --- FIN LOGIQUE ---

                if (generatedSessions.length > 0) {
                    totalHoursEl.textContent = totalHours.toLocaleString(currentLang, { minimumFractionDigits: 1, maximumFractionDigits: 2 });
                    totalHoursDisplay.style.display = 'block';
                } else {
                    resultsList.textContent = t.noSessionsMsg;
                    totalHoursDisplay.style.display = 'none';
                }
                
                renderResults();
                return true; // Succès
            }

            // --- Écouteurs pour les options de formatage ---
            if (showDayOfWeek) showDayOfWeek.addEventListener('change', renderResults);
            if (showYear) showYear.addEventListener('change', renderResults);
            if (copyFormatVertical) copyFormatVertical.addEventListener('change', renderResults);
            if (copyFormatHorizontal) copyFormatHorizontal.addEventListener('change', renderResults);

            function renderResults() {
                if (!copyPreview || !resultsList) return;

                if (generatedSessions.length === 0) {
                    copyPreview.textContent = "";
                    const t = translations[currentLang];
                    if (resultsList.textContent.startsWith(t.errorMsg) || resultsList.textContent.startsWith(t.noSessionsMsg)) {
                        // Ne rien faire, garder le message
                    } else {
                        resultsList.textContent = ""; // Vider
                    }
                    return;
                }

                const options = {
                    showDay: showDayOfWeek.checked,
                    showYear: showYear.checked
                };
                
                const outputList = generatedSessions.map(session => {
                    const dateString = formatDate(session.date, currentLang, options);
                    return `${dateString} de ${session.slot.start} à ${session.slot.end}`;
                });

                resultsList.textContent = outputList.join('\n');
                
                const copyFormat = copyFormatVertical.checked ? 'vertical' : 'horizontal';
                const separator = copyFormat === 'vertical' ? '\n' : ' - ';
                copyPreview.textContent = outputList.join(separator);
            }

            if (copyBtn) {
                copyBtn.addEventListener('click', () => {
                    const textToCopy = copyPreview.textContent;
                    if (!textToCopy) return;

                    // MISE À JOUR: Utiliser l'API Clipboard moderne
                    navigator.clipboard.writeText(textToCopy).then(() => {
                        // Animation de succès
                        copyFeedbackSuccess.style.opacity = '1';
                        copyBtnText.style.opacity = '0';
                        
                        setTimeout(() => {
                            copyFeedbackSuccess.style.opacity = '0';
                            copyBtnText.style.opacity = '1';
                        }, 2000);

                    }).catch(err => {
                        // Fallback vers l'ancienne méthode (pour http ou permissions)
                        console.warn('Échec de navigator.clipboard, tentative avec execCommand...', err);
                        try {
                            const textArea = document.createElement('textarea');
                            textArea.value = textToCopy;
                            textArea.style.position = 'fixed';
                            textArea.style.top = '0';
                            textArea.style.left = '0';
                            textArea.style.opacity = '0';
                            document.body.appendChild(textArea);
                            textArea.focus();
                            textArea.select();
                            
                            document.execCommand('copy');
                            
                            copyFeedbackSuccess.style.opacity = '1';
                            copyBtnText.style.opacity = '0';
                            setTimeout(() => {
                                copyFeedbackSuccess.style.opacity = '0';
                                copyBtnText.style.opacity = '1';
                            }, 2000);
                            
                            document.body.removeChild(textArea);
                        } catch (err2) {
                            console.error('Échec du fallback execCommand :', err2);
                        }
                    });
                });
            }

            // --- NOUVELLES FONCTIONS DU WIZARD ---

            function updateWizardUI() {
                const t = translations[currentLang];

                wizardSteps.forEach((step, index) => {
                    step.style.display = (index + 1 === currentStep) ? 'block' : 'none';
                });

                stepDots.forEach(dot => {
                    const step = parseInt(dot.dataset.step);
                    dot.classList.toggle('active', step === currentStep);
                });

                prevBtn.textContent = t.back;
                prevBtn.style.visibility = (currentStep === 1) ? 'hidden' : 'visible';

                if (currentStep === totalSteps) { 
                    nextBtn.style.display = 'none'; 
                } else if (currentStep === totalSteps - 1) { 
                    nextBtn.style.display = 'inline-block';
                    nextBtn.textContent = t.generateBtn; 
                    nextBtn.classList.add('bg-emerald-600', 'hover:bg-emerald-700');
                    nextBtn.classList.remove('bg-indigo-600', 'hover:bg-indigo-700');
                } else { 
                    nextBtn.style.display = 'inline-block';
                    nextBtn.textContent = t.next; 
                    nextBtn.classList.remove('bg-emerald-600', 'hover:bg-emerald-700');
                    nextBtn.classList.add('bg-indigo-600', 'hover:bg-indigo-700');
                }
            }

            if (nextBtn) {
                nextBtn.addEventListener('click', () => {
                    if (currentStep === totalSteps - 1) { 
                        const generationSuccess = runGenerationLogic();
                        if (generationSuccess) {
                            currentStep++; 
                        }
                    } else if (currentStep < totalSteps) {
                        currentStep++;
                    }
                    updateWizardUI();
                });
            }

            if (prevBtn) {
                prevBtn.addEventListener('click', () => {
                    if (currentStep > 1) {
                        currentStep--;
                    }
                    updateWizardUI();
                });
            }

            stepDots.forEach(dot => {
                dot.addEventListener('click', () => {
                    const targetStep = parseInt(dot.dataset.step);
                    if (targetStep < currentStep) { 
                        currentStep = targetStep;
                        updateWizardUI();
                    } else if (targetStep === totalSteps && currentStep === totalSteps -1) {
                        if (nextBtn) nextBtn.click(); // Simule le clic sur "Générer"
                    }
                });
            });

            // --- FONCTIONS UTILITAIRES ---
            function parseDateAsUTC(dateStr) {
                if (!dateStr) return null;
                const parts = dateStr.split('-').map(Number);
                if (parts.length === 3 && !parts.some(isNaN)) {
                    const [year, month, day] = parts;
                    return new Date(Date.UTC(year, month - 1, day));
                }
                return null;
            }

            function formatDate(date, lang, options) {
                if (!date || !(date instanceof Date)) return "";
                const { showDay, showYear } = options;
                const formatOptions = {
                    day: 'numeric',
                    month: 'long',
                    timeZone: 'UTC' 
                };
                if (showDay) formatOptions.weekday = 'long';
                if (showYear) formatOptions.year = 'numeric';
                
                let str = date.toLocaleDateString(lang, formatOptions);
                return str.charAt(0).toUpperCase() + str.slice(1);
            }

            // --- INITIALISATION ---
            const today = new Date();
            const todayStr = today.toISOString().split('T')[0];
            today.setDate(today.getDate() + 30);
            const endDateStr = today.toISOString().split('T')[0];

            const startDateEl = app.querySelector('[data-id="start-date"]');
            const breakStartEl = app.querySelector('[data-id="break-start"]');
            const breakEndEl = app.querySelector('[data-id="break-end"]');
            const globalEndDateEl = app.querySelector('[data-id="global-end-date"]');

            if (startDateEl) startDateEl.value = todayStr;
            if (breakStartEl) breakStartEl.value = todayStr;
            if (breakEndEl) breakEndEl.value = todayStr;
            if (globalEndDateEl) globalEndDateEl.value = endDateStr;
            
            setLanguage('fr');
            updateWizardUI();
        }

        // Lancer l'application après le chargement du DOM
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', initScheduleGenerator);
        } else {
            // DOM déjà chargé (cas Odoo)
            initScheduleGenerator();
        }
    </script>
</body>
</html>

